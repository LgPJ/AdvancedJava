Es la capacidad de hacer más de una cosa al mismo tiempo.

Concurrencia se da cuando dos o más tareas se desarrollan en el mismo intervalo de tiempo.
El paralelismo, el cual consiste en llevar a cabo multitareas en el mismo instante literalmente.

    Beneficios:
    *Incremento de rendimiento
    *es el futuro
    *Posibilidad de hacer tareas en segundo plano
    *aplicaciones asincronas

   Inconvenientes:
    *programas mas complejos
    *aumento del numero de errores
    *dificil de depurar
    *posible indeterminacion

Flujo de ejecucion
    El hilo principal se ejecuta en el MAIN, ejecutando todas las instrucciones que estan contenidas dentro de el.
        *al llegar a la creacion del hilo.start() crea el nuevo hilo, pero sigue en su ejecucion de lineas internas.
            Nota: al ingresar a las sentencias definidas dentro del metodo (Nuevo hilo generado) run a su vez continua con las sentencias que estan definidas dentro del hilo principal.

EL ORDEN DE EJECUCION DE LOS HILOS, NO LO SABEMOS, EL CPU SE ENCARGA DE ESO......

/***********************************************************************************************************/
Metodo JOIN]()

    Con este metodo se le indica al hilo donde esta contenido, que debe esperar a los demas hilos que sean finalizados

    Ejemplo de lanzados de hilos desde vectores
    for(int i = 0; i < length; i++) {
        vec[i] = new Clase();
    }

    for(int i = 0; i< vec.length; i++){
         vec[i].start();
    }

    JOIN(): El metodo hace que este el hilo que esta en ejecucion espera que los demas hilos se ejecuten
    este metodo es para que el hilo en curso espere a los demas

    ejemplo: 

    try{

        vec[0].join();
        El hilo principal va a esperar que el hilo contenido dentro de la posicion 0 del vector se ejecute
        para asi el proceder a ejecutarse, siempre va a estar detras del hilo de esa posicion indicada
        NOTA: no necesariamente se debe hacer despues de la ejecucion del hilo en la posicion 0, pero si siempre sera despues.

    }catch(Exception ex){}

    System.out.println("Principal");
    
/***********************************************************************************************************/
    Metodo sleep()
        Este metodo bloquea el hilo donde esta definido, es una pausa generada en milisegundos

/***********************************************************************************************************/
INDETERMINISMO: cuando dos o mas hilos estan ejecutando(Escribiendo) sobre una variable compartida, el valor de dicha variable es indeterminado.

Concurrencia: 
    Se ejecuta una tarea en varios nucleos.
    El cpu le asigna a cada tarea un tiempo determinado.
    Dos o mas tareas no se estan ejecutando al mismo tiempo.

Paralelismo:
    Ejecucion de dos o mas tareas a la vez.
    Se ejecuta 1 tarea e un nucleo.
    Es mas rapido que la concurrencia.

/***********************************************************************************************************/  
Hilos dinamicos
    La forma de saber las caracteristicas del pc donde se ejecuta el programa se usa Runtime
        Runtime: Con esta clase podemos abrir otros programas. Por ejemplo Microsoft Word, Excel, PowerPoint, notepad, internet Explorer, etc.


    Runtime.getRuntime(): Obtenemos el objeto que contiene los datos del procesador y sus caracteristicas.
    runtime.availableProcessors();

/***********************************************************************************************************/ 
Runnable y Synchronized

    Con runnable se implementa y por consiguiente se debe sobre escribir el metodo run
    El lanzado de los hilos se hace de la misma forma que extendiendo de thread
    pero se crean objetos del tipo Runnable

    Runnable clase = new Clase();

    al no poder acceder desde objetos Runnable al metodo start se deben crear objetos Thread para asi, utilizar un constructor 
    que recibe objetos tipo thread

    Runnable clase = new Clase();
    Thread hilo = new Thread(clase);
    hilo.start();

    lanzado de hilos en vectores con runnable
    Thread[] hilos = new Thread[2];

    for(int i = 0; i < hilos.length; i++){
        Runnable run = new Clase();
        hilos[i] = new Thread(run);

        hilos[i].start();
    }

/***********************************************************************************************************/ 
   Condicion de Guarda, wait y notifyAll

   synchronized: genera una cola para eliminar indeterminacion en los hilos y que todos se ejecuten de manera ordenada

   wait: genera un cola de hilos dormidos esperando la ejecucion.

   notifyAll: despierta todo el conjunto de hilos que estan dormido dentro de una cola